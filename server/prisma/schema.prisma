generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [postgis]
}

// ─────────────── Enums ───────────────

enum NoteVisibility {
  PRIVATE
  FRIENDS
  GROUP
  PUBLIC
}

enum FriendshipStatus {
  PENDING
  ACCEPTED
  REJECTED
}

enum GroupMemberRole {
  OWNER
  ADMIN
  MEMBER
}

enum GroupVisibility {
  PUBLIC
  FRIENDS_ONLY
}

enum UserRole {
  USER
  ADMIN
}

// ─────────────── Models ───────────────

model User {
  id           String    @id @default(uuid())
  firebase_uid String    @unique
  email        String    @unique
  username     String    @unique
  avatar_url   String?
  role         UserRole  @default(USER)
  created_at   DateTime  @default(now())
  updated_at   DateTime  @updatedAt

  notes                 Note[]
  friendships_initiated Friendship[]  @relation("Initiator")
  friendships_received  Friendship[]  @relation("Receiver")
  groups_owned          Group[]       @relation("GroupOwner")
  group_memberships     GroupMember[]

  @@map("users")
}

model Note {
  id         String                              @id @default(uuid())
  owner_id   String
  group_id   String?
  title      String
  content    String
  location   Unsupported("geography(Point,4326)")
  visibility NoteVisibility                      @default(PRIVATE)
  created_at DateTime                            @default(now())
  updated_at DateTime                            @updatedAt
  deleted_at DateTime?

  owner User   @relation(fields: [owner_id], references: [id], onDelete: Cascade)
  group Group? @relation(fields: [group_id], references: [id], onDelete: SetNull)

  @@index([owner_id])
  @@index([group_id])
  @@index([visibility])
  @@index([deleted_at])
  @@index([created_at])
  // Spatial GIST index is added manually in migration SQL:
  // CREATE INDEX notes_location_idx ON notes USING GIST (location);
  @@map("notes")
}

model Group {
  id         String          @id @default(uuid())
  name       String
  owner_id   String
  visibility GroupVisibility @default(PUBLIC)
  created_at DateTime        @default(now())
  updated_at DateTime        @updatedAt

  owner   User          @relation("GroupOwner", fields: [owner_id], references: [id], onDelete: Cascade)
  members GroupMember[]
  notes   Note[]

  @@index([owner_id])
  @@map("groups")
}

model GroupMember {
  id       String          @id @default(uuid())
  group_id String
  user_id  String
  role     GroupMemberRole @default(MEMBER)

  group Group @relation(fields: [group_id], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([group_id, user_id])
  @@index([user_id])
  @@map("group_members")
}

// friendship between two users
model Friendship {
  id           String           @id @default(uuid())
  initiator_id String
  receiver_id  String
  status       FriendshipStatus @default(PENDING)
  created_at   DateTime         @default(now())
  updated_at   DateTime         @updatedAt

  initiator User @relation("Initiator", fields: [initiator_id], references: [id], onDelete: Cascade)
  receiver  User @relation("Receiver", fields: [receiver_id], references: [id], onDelete: Cascade)

  @@unique([initiator_id, receiver_id])
  @@index([receiver_id])
  @@index([status])
  @@map("friendships")
}
